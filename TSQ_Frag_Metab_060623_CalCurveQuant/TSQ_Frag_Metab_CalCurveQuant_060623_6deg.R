# This script will make calibration curves after normalizing to BMIS and get quant


# Load required packages into environment
library(ggplot2)
library(dplyr)
library(raster)
library(MetBrewer)
library(tidyr)
library(car)
library(ggpubr)

# Start working directory the TSQ_Frag_Metab_060623 folder
setwd("~/Dropbox (Bertrand Lab)/Bertrand Lab's shared workspace/Catalina/Summer_2022/1_FracyPibo_Beyond_Auxotrophy/BA_Frag_Quotas/TSQ_Frag_Metab_060623")

# Set working directory
setwd("./TSQ_Frag_Metab_060623_RawData")

# Get calibration curve data
CalCurve_df <- read.csv("ER3_149_Frag_Catalina_01_Cal03022022_output.csv")

# Change wd to CalCurveQuant folder
setwd("../TSQ_Frag_Metab_060623_CalCurveQuant")

# Load in list that checks for calibration curve
cal_data_sum <- read.csv("TSQ_Metab_CalSum.csv")

# Data Cleanup ------------------------------------------------------------


# Create df for calibration curves
CalCurve_df <- CalCurve_df %>% # Replace DMB name for just acronym
  mutate(
    Molecule.Name = replace(
      Molecule.Name,
      Molecule.Name == "Dimethyl-benzimidazole (DMB)",
      "DMB"
    )
  ) %>%
  dplyr::filter(!grepl("blk", Replicate.Name)) # Remove data from blanks

# Create df with no heavy compound data
CalCurve_cals <- CalCurve_df %>% filter(!grepl('heavy', Molecule.Name)) # Remove data from heavy peaks

# Get Normalized Peaks (divide each light QC peak by each heavy QC peak) ------------

# Create a list of heavy compounds to normalize to
heavy_compounds <- c("B1", "B2", "B12-CN", "B7")

# Create a function that does the normalization
norm_peaks <- function(compound_name) {
  # Index for compound from CalCurve_df
  heavy <-
    CalCurve_df %>% filter(Molecule.Name == paste(compound_name, "-heavy", sep = ""))
  
  # Amend areas of the heavy compound to the CalCurve_cals df
  CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")] <-
    heavy$Total.Area
  
  # Calculate normalized peaks by dividing each compound by the heavy peak
  CalCurve_cals[paste("Heavy", compound_name, "Norm", sep = ".")] <-
    CalCurve_cals$Total.Area / CalCurve_cals[paste("Heavy", compound_name, "Peaks", sep = ".")]
  
  assign("CalCurve_cals", CalCurve_cals, envir = globalenv())
  
}

# Apply function over all 4 heavy compounds
lapply(heavy_compounds, norm_peaks)




# Select BMIS (best matched internal standard) and produce final peak to be used for plotting and quantification  -------------------------------------------------------------

# Notes: 
# Generate final peaks based on BMIS used 
# Will use "matching compounds" (ex: B12's to CNB12, B1 to heavy B1, B2 to heavy B2). 
# For others, will use a compound as BMIS if improves cv by >30%
# B7 was not matched to heavy B7 due to an increase in cv


setwd("../TSQ_Frag_Metab_060623_BMIS")

# Load in BMIS results (generated by TSQ_Frag_Metab_BMIS_25042022.R )
BMIS.Data <- read.csv("QC_BMIS_results_sum.csv") %>% 
  dplyr::select(Molecule.Name, BMIS_used)

# Join BMIS and calibration curve data
CalCurve_BMIS <-
  left_join(CalCurve_cals, BMIS.Data, by = "Molecule.Name") %>%
  dplyr::select(
    # select only needed columns
    Replicate.Name,
    Molecule.Name,
    Total.Area,
    Heavy.B1.Norm,
    Heavy.B2.Norm,
    `Heavy.B12-CN.Norm`,
    Heavy.B7.Norm,
    BMIS_used
  ) %>%
  rename(Heavy.CNB12.Norm = `Heavy.B12-CN.Norm`) %>% # rename cnb12
  mutate(BMIS_col_name = paste("Heavy.", BMIS_used, ".Norm", sep = "")) %>%
  dplyr::filter(!grepl("heavy",Replicate.Name)) # Remove heavy entries


# Function for selecting which measure to use
# Script looks at each line, look at BMIS. If "none", there is no best matched internal standard and the script will make final measure the unnormalized one
# If not none, match BMIS to the heavy column and use this value

for (i in 1:nrow(CalCurve_BMIS)){
  if (CalCurve_BMIS$BMIS_used[i] == "none"){
    CalCurve_BMIS$Final_Peak[i] <-  CalCurve_BMIS$Total.Area[i]
  } 
   else {
     CalCurve_BMIS$Final_Peak[i] <- CalCurve_BMIS[i,as.character(CalCurve_BMIS$BMIS_col_name[i])]
   }
}



# Get LOD's and LOQ's for each compound with a authentic standard ---------


# Prepare and LOQ/LOD df
LODQ_df <- CalCurve_BMIS %>% filter(grepl("p5", Replicate.Name)) %>%
  group_by(Molecule.Name) %>%
  dplyr::summarise(
    sd_peak = sd(Final_Peak), # calculate standard dev. (sd)
    LOD = 3 * sd(Final_Peak), # Limit of detection is 3 times the sd of the peak
    LOQ = 5 * sd(Final_Peak) # Limit of quantification is 5 times the sd of the peak
  )

# Narrow df to only include those with a curve
LODQ_df <- LODQ_df[ LODQ_df$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Write out list of LOQ/D
write.csv(LODQ_df, file = "LODQ_export.csv")

# Remove entries that don't have calibration curves
cal_data_sum <- filter(cal_data_sum, Cal_done == "Y") 

# Narrow calibration dataframe to only include those with a curve
CalCurve_BMIS <- CalCurve_BMIS[ CalCurve_BMIS$Molecule.Name %in% cal_data_sum$Molecule.Name, ]

# Change wd 
setwd("../TSQ_Frag_Metab_060623_CalCurveQuant")

# Relate sample names to amount spiked
# 1 and 5 is how much spiked (if 1, amounts in sample name are correct. ex: p5fmol = 0.5 fmol spike. if 5, 5x that. ex: p5fmol = 2.5 fmol )
spike_amounts <- read.csv("spike_amount_calcurve.csv")

# Match correct spike amount next to each replicate
# The B12's and DMB were spiked in 1/5 conc of other authentic standards
cal_spike <-
  left_join(CalCurve_BMIS, spike_amounts, by = "Replicate.Name") %>% 
  inner_join(cal_data_sum, by = "Molecule.Name") %>%
  mutate(spike_amount_corr = NULL) # Add a blank column for corrected spike amounts 


# Make a loop that selects the correct spike amount to use (either 1x for B12's and DMB or 5x for everything else)
for (i in 1:nrow(cal_spike)) {
  if (cal_spike$Cal_amount[i] == "5") {
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_5[i]
  }
  else{
    cal_spike$spike_amount_corr[i] <- cal_spike$spiked_1[i]
  }
}


# Trim down to only useful info
cal_spike <-
  cal_spike %>% dplyr::select(Replicate.Name,
                              Molecule.Name,
                              BMIS_used,
                              Final_Peak,
                              spike_amount_corr)
  





# Get Linear Models for Compounds with Curves -----------------------------

# Cal compounds with non-linear curves: DMSP, GBT, Homarine, Methionine, Proline (are excludeD)
#NOTE: Make into function and export table of compound slopes and rsq's

lm_calcurve <- function(molecule.name) {
  molecule.name = "B1"
  
  
  B1_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B1")
  B1_lm <- lm(spike_amount_corr ~ Final_Peak , data = B1_curve)
  summary(B1_lm)
  B1_rsq <- as.numeric(summary(B1_lm)$r.squared)
}

#B1
B1_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B1")
B1_lm <- lm(spike_amount_corr ~ Final_Peak , data = B1_curve)
summary(B1_lm)
B1_rsq <- as.numeric(summary(B1_lm)$r.squared)

#Ado-B12
# Use only bottom 3 points for this one (50 and 100 fmol spikes show the same response)
B12Ado_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B12-Ado") %>% filter(spike_amount_corr <= 10)
B12Ado_lm <- lm(spike_amount_corr ~ Final_Peak, data = B12Ado_curve)
summary(B12Ado_lm)
B12Ado_rsq <- as.numeric(summary(B12Ado_lm)$r.squared)

# Plot new Ado-B12 curve
ggplot(B12Ado_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Ado-B12")

#CN-B12
B12CN_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B12-CN")
B12CN_lm <- lm(spike_amount_corr ~ Final_Peak, data = B12CN_curve)
summary(B12CN_lm)
B12CN_rsq <- as.numeric(summary(B12CN_lm)$r.squared)

#Me-B12
# Use only bottom 3 points for this one (50 and 100 fmol spikes' response is the same)
B12Me_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B12-Me") %>% filter(spike_amount_corr <= 10)
B12Me_lm <- lm(spike_amount_corr ~ Final_Peak, data = B12Me_curve)
summary(B12Me_lm)
B12Me_rsq <- as.numeric(summary(B12Me_lm)$r.squared)

# Plot Me-B12 curve
ggplot(B12Me_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Me-B12")

#OH-B12
B12OH_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B12-OH") 
B12OH_lm <- lm(spike_amount_corr ~ Final_Peak, data = B12OH_curve)
summary(B12OH_lm)
B12OH_rsq <- as.numeric(summary(B12OH_lm)$r.squared)



#B7
B7_curve <- subset(cal_spike, cal_spike$Molecule.Name== "B7")
B7_lm <- lm(spike_amount_corr ~ Final_Peak, data = B7_curve)
summary(B7_lm)
B7_rsq <- as.numeric(summary(B7_lm)$r.squared)

# cHET
cHET_curve <- subset(cal_spike, cal_spike$Molecule.Name== "cHET")
cHET_lm <- lm(spike_amount_corr ~ Final_Peak, data = cHET_curve)
summary(cHET_lm)
cHET_rsq <- as.numeric(summary(cHET_lm)$r.squared)

#DMB
DMB_curve <- subset(cal_spike, cal_spike$Molecule.Name== "DMB")
DMB_lm <- lm(spike_amount_corr ~ Final_Peak, data = DMB_curve)
summary(DMB_lm)
DMB_rsq <- as.numeric(summary(DMB_lm)$r.squared)

# FAMP
FAMP_curve <- subset(cal_spike, cal_spike$Molecule.Name== "FAMP")
FAMP_lm <- lm(spike_amount_corr ~ Final_Peak, data = FAMP_curve)
summary(FAMP_lm)
FAMP_rsq <- as.numeric(summary(FAMP_lm)$r.squared)

# GBT
GBT_curve <- subset(cal_spike, cal_spike$Molecule.Name== "FAMP")
GBT_lm <- lm(spike_amount_corr ~ Final_Peak, data = GBT_curve)
summary(FAMP_lm)
GBT_rsq <- as.numeric(summary(GBT_lm)$r.squared)

#HET
HET_curve <- subset(cal_spike, cal_spike$Molecule.Name== "HET")
HET_lm <- lm(spike_amount_corr ~ Final_Peak, data = HET_curve)
summary(HET_lm)
HET_rsq <- as.numeric(summary(HET_lm)$r.squared)

#HMP
HMP_curve <- subset(cal_spike, cal_spike$Molecule.Name== "HMP")
HMP_lm <- lm(spike_amount_corr ~ Final_Peak, data = HMP_curve)
summary(HMP_lm)
HMP_rsq <- as.numeric(summary(HMP_lm)$r.squared)

# SAH
SAH_curve <- subset(cal_spike, cal_spike$Molecule.Name== "SAH")
SAH_lm <- lm(spike_amount_corr ~ Final_Peak, data = SAH_curve)
summary(SAH_lm)
SAH_rsq <- as.numeric(summary(SAH_lm)$r.squared)

# SAM
SAM_curve <- subset(cal_spike, cal_spike$Molecule.Name== "SAM")
SAM_lm <- lm(spike_amount_corr ~ Final_Peak, data = SAM_curve)
summary(SAM_lm)
SAM_rsq <- as.numeric(summary(SAM_lm)$r.squared)

# TMP
TMP_curve <- subset(cal_spike, cal_spike$Molecule.Name== "TMP")
TMP_lm <- lm(spike_amount_corr ~ Final_Peak, data = TMP_curve)
summary(TMP_lm)
TMP_rsq <- as.numeric(summary(TMP_lm)$r.squared)

# Proline
proline_curve <- subset(cal_spike, cal_spike$Molecule.Name== "Proline")
proline_lm <- lm(spike_amount_corr ~ Final_Peak, data = proline_curve)
summary(proline_curve)
proline_rsq <- as.numeric(summary(proline_curve)$r.squared)



# Load in Sample Data and Match to BMIS ------------------------------------------------------
# Change wd
setwd("../TSQ_Frag_Metab_060623_RawData")

metab_data <- read.csv("ER3_149_Frag_Catalina_01_03022022_output.csv") %>% dplyr::select(Replicate.Name, Molecule.Name, Total.Area) %>% dplyr::filter(nchar(Replicate.Name) < 7)



# Get Heavy B1 Normalized peaks (divide peaks by heavy B1)
Heavy.B1.peaks_samples <-  metab_data %>% filter(Molecule.Name == "B1-heavy")
metab_data$Heavy.B1.peaks_samples <- Heavy.B1.peaks_samples$Total.Area
metab_data$Heavy.B1.Norm <- metab_data$Total.Area /metab_data$Heavy.B1.peaks_samples

# Get heavy B2 normalized peaks (divide peaks by heavy B2)
Heavy.B2.peaks_samples <-  metab_data %>% filter(Molecule.Name == "B2-heavy")
metab_data$Heavy.B2.peaks_samples <- Heavy.B2.peaks_samples$Total.Area
metab_data$Heavy.B2.Norm <- metab_data$Total.Area /metab_data$Heavy.B2.peaks_samples

# Get heavy CN-B12 normalized peaks (divide peaks by heavy CN-B12)
Heavy.CNB12.peaks_samples <-  metab_data %>% filter(Molecule.Name == "B12-CN-heavy")
metab_data$Heavy.CNB12.peaks_samples <- Heavy.CNB12.peaks_samples$Total.Area
metab_data$Heavy.CNB12.Norm <- metab_data$Total.Area /metab_data$Heavy.CNB12.peaks_samples

# Get heavy B7 normalized peaks (divide peaks by heavy CN-B12)
Heavy.B7.peaks_samples <-  metab_data %>% filter(Molecule.Name == "B12-CN-heavy")
metab_data$Heavy.B7.peaks_samples <- Heavy.B7.peaks_samples$Total.Area
metab_data$Heavy.B7.Norm <- metab_data$Total.Area /metab_data$Heavy.B7.peaks_samples

# Join sample metab data to sample info 
metab_data_norm <- left_join(metab_data, BMIS.Data, by = "Molecule.Name")

# Do final norms with BMIS
metab_data_norm$BMIS_col_name <- paste("Heavy.",metab_data_norm$BMIS_used,".Norm", sep = "")

# Remove heavy entries
metab_data_norm <- dplyr::filter(metab_data_norm, !grepl("heavy",Molecule.Name)) 

# Do final norms with BMIS
metab_data_norm$BMIS_col_name <- paste("Heavy.",metab_data_norm$BMIS_used,".Norm", sep = "")

# Remove heavy entries
metab_data_norm <- dplyr::filter(metab_data_norm, !grepl("heavy",Molecule.Name)) 

metab_data_norm$Final_Peak <- NA

# Loop to select right peak
for (i in 1:nrow(metab_data_norm)){
  if (metab_data_norm$BMIS_used[i] == "none"){
    metab_data_norm$Final_Peak[i] <-  metab_data_norm$Total.Area[i]
  } else {
    metab_data_norm$Final_Peak[i] <- metab_data_norm[i,as.character(metab_data_norm$BMIS_col_name[i])]
  }
}

# Change wd 
setwd("../TSQ_Frag_Metab_060623_CalCurveQuant")

# Load in file with cells per filter data
cell_nos <- read.csv("B_sample_info_loading_220116.csv")

# Add a zero to the single digit sample numbers
cell_nos$Extract.ID <- sprintf("%02d", cell_nos$Extract.ID)
colnames(cell_nos)[1] <- "Replicate.Name"

# Split replicate name to remove injection number
metab_data_norm <- metab_data_norm %>% separate(Replicate.Name, c("Replicate.Name", NA))

# Join data to sample info (treatment, cells)
metab_data_samples_info <- left_join(metab_data_norm, cell_nos, by = "Replicate.Name") %>% filter(Temperature.Treatment == "6") %>% dplyr::select(Replicate.Name, Total.Area, Molecule.Name, BMIS_used, Final_Peak, Temperature.Treatment, B12.Treatment, cells_on_column, mgC_cell, culture_replicate_no)


# Get fmol/mgC
metab_data_samples_info$mgC_loaded <- metab_data_samples_info$cells_on_column * metab_data_samples_info$mgC_cell

# Change B12 to factor for plotting
metab_data_samples_info$B12.Treatment <- factor(metab_data_samples_info$B12.Treatment, levels = c("Y", "N"))
levels(metab_data_samples_info$B12.Treatment) <- c("+", "-")                        
                                      
# Correct Curves and Get Quant --------------------------------------------
# function for getting r squared and equation onto plot
lm_eqn <- function(df){
  m <- lm(Final_Peak ~ spike_amount_stadd_corr, df);
  eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
                   list(a = format(unname(coef(m)[1]), digits = 2),
                        b = format(unname(coef(m)[2]), digits = 2),
                        r2 = format(summary(m)$r.squared, digits = 3)))
  as.character(as.expression(eq));
}

# B1 Quant ----------------------------------------------------------------
# Plot B1 curve with lm 
B1_calcurve <- ggplot(B1_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B1") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B1_curve$spike_amount_stadd_corr <- B1_curve$spike_amount_corr - as.numeric(coef(B1_lm)["(Intercept)"])

# Plot corrected calibration curve
B1_calcurve_corrected <- ggplot(B1_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  ggtitle("Calibration Curve: B1 (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 1000) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B1"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B1"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 300, y = 17, label = lm_eqn(B1_curve), parse = TRUE)

# Make corrected lm
B1_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B1_curve)

#Creating a data frame with B1 peaks from samples 
B1_df <- metab_data_samples_info %>% filter(Molecule.Name == "B1") 
B1_peak_df <- B1_df %>% dplyr::select(Final_Peak) 
colnames(B1_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
B1_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B1_peak_df)){
  if (B1_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B1"))$LOD){
    B1_df$Below_LOD[i] <- TRUE
    B1_df$Final_Peak[i] <- 0
  }
  else{
    B1_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B1_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B1_peak_df)){
  if (B1_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B1"))$LOQ){
    B1_df$Below_LOQ[i] <- TRUE
  }
  else{
    B1_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B1_df$normtype <- "BMIS_cell"
B1_df$normunits <- "fmol_cell"

# Predict quant values from lm
B1_quant <- data.frame(predict(B1_lm_corr, newdata = B1_peak_df)) 
colnames(B1_quant) <- "est_fmol_on_column"
B1_df <- cbind(B1_df, B1_quant)

# Calculate fmol per mg C, cell, and peak per cell
B1_df$fmol_cell <- B1_df$est_fmol_on_column/B1_df$cells_on_column
B1_df$fmol_mgC <- B1_df$est_fmol_on_column/B1_df$mgC_loaded
B1_df$peak_cell <- B1_df$Final_Peak/B1_df$cells_on_column



# B12Ado Quant ----------------------------------------------------------------
# Plot B12Ado curve with lm 
B12Ado_calcurve <- ggplot(B12Ado_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12Ado") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B12Ado_curve$spike_amount_stadd_corr <- B12Ado_curve$spike_amount_corr - as.numeric(coef(B12Ado_lm)["(Intercept)"])

# Plot corrected calibration curve
B12Ado_calcurve_corrected <- ggplot(B12Ado_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Ado-B12 (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 6.5, y = .2, label = lm_eqn(B12Ado_curve), parse = TRUE)

# Make corrected lm
B12Ado_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B12Ado_curve)

#Creating a data frame with B12Ado peaks from samples 
B12Ado_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-Ado")
B12Ado_peak_df <- B12Ado_df %>% dplyr::select(Final_Peak) 
colnames(B12Ado_peak_df) <- "Final_Peak"

B12Ado_df_expraw <- B12Ado_df

# Make an ado B12 plot for all reps
# B12Ado_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12Ado_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("Ado-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))




# Create an empty column for knowing if sample is below LOD
B12Ado_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Ado_peak_df)){
  if (B12Ado_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOD){
    B12Ado_df$Below_LOD[i] <- TRUE
    B12Ado_df$Final_Peak[i] <- 0
  }
  else{
    B12Ado_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12Ado_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Ado_peak_df)){
  if (B12Ado_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Ado"))$LOQ){
    B12Ado_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12Ado_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12Ado_df$normtype <- "BMIS_cell"
B12Ado_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12Ado_quant <- data.frame(predict(B12Ado_lm_corr, newdata = B12Ado_peak_df)) 
colnames(B12Ado_quant) <- "est_fmol_on_column"
B12Ado_df <- cbind(B12Ado_df, B12Ado_quant)

# Calculate fmol per mg C and cell
B12Ado_df$fmol_cell <- B12Ado_df$est_fmol_on_column/B12Ado_df$cells_on_column
B12Ado_df$fmol_mgC <- B12Ado_df$est_fmol_on_column/B12Ado_df$mgC_loaded
B12Ado_df$peak_cell <- B12Ado_df$Final_Peak/B12Ado_df$cells_on_column


# B12OH Quant ----------------------------------------------------------------
# Plot B12OH curve with lm 
B12OH_calcurve <- ggplot(B12OH_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12OH") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B12OH_curve$spike_amount_stadd_corr <- B12OH_curve$spike_amount_corr - as.numeric(coef(B12OH_lm)["(Intercept)"])

# Plot corrected calibration curve
B12OH_calcurve_corrected <- ggplot(B12OH_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: OH-B12 (Corrected)") +
  ylim(0,35) +
 # xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 40, y = 30, label = lm_eqn(B12OH_curve), parse = TRUE)

# Make corrected lm
B12OH_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B12OH_curve)

#Creating a data frame with B12OH peaks from samples 
B12OH_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-OH")
B12OH_peak_df <- B12OH_df %>% dplyr::select(Final_Peak) 
colnames(B12OH_peak_df) <- "Final_Peak"

B12OH_df_expraw <- B12OH_df
# B12OH_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12OH_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("OH-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))

# Create an empty column for knowing if sample is below LOD
B12OH_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12OH_peak_df)){
  if (B12OH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOD){
    B12OH_df$Below_LOD[i] <- TRUE
    B12OH_df$Final_Peak[i] <- 0
  }
  else{
    B12OH_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12OH_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12OH_peak_df)){
  if (B12OH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-OH"))$LOQ){
    B12OH_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12OH_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12OH_df$normtype <- "BMIS_cell"
B12OH_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12OH_quant <- data.frame(predict(B12OH_lm_corr, newdata = B12OH_peak_df)) 
colnames(B12OH_quant) <- "est_fmol_on_column"
B12OH_df <- cbind(B12OH_df, B12OH_quant)

# Calculate fmol per mg C and cell
B12OH_df$fmol_cell <- B12OH_df$est_fmol_on_column/B12OH_df$cells_on_column
B12OH_df$fmol_mgC <- B12OH_df$est_fmol_on_column/B12OH_df$mgC_loaded
B12OH_df$peak_cell <- B12OH_df$Final_Peak/B12OH_df$cells_on_column

# B12CN Quant ----------------------------------------------------------------
# Plot B12CN curve with lm 
B12CN_calcurve <- ggplot(B12CN_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12CN") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B12CN_curve$spike_amount_stadd_corr <- B12CN_curve$spike_amount_corr - as.numeric(coef(B12CN_lm)["(Intercept)"])

# Plot corrected calibration curve
B12CN_calcurve_corrected <- ggplot(B12CN_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: CN-B12 (Corrected)") +
  #ylim(0,1600000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 37, y = 15, label = lm_eqn(B12CN_curve), parse = TRUE)

# Make corrected lm
B12CN_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B12CN_curve)

#Creating a data frame with B12CN peaks from samples 
B12CN_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-CN")
B12CN_peak_df <- B12CN_df %>% dplyr::select(Final_Peak) 
colnames(B12CN_peak_df) <- "Final_Peak"

B12CN_df_expraw <- B12CN_df

# Create an empty column for knowing if sample is below LOD
B12CN_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12CN_peak_df)){
  if (B12CN_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOD){
    B12CN_df$Below_LOD[i] <- TRUE
    B12CN_df$Final_Peak[i] <- 0
  }
  else{
    B12CN_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12CN_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12CN_peak_df)){
  if (B12CN_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-CN"))$LOQ){
    B12CN_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12CN_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12CN_df$normtype <- "none"
B12CN_df$normunits <- "none"

# Predict quant values from lm
B12CN_quant <- data.frame(predict(B12CN_lm_corr, newdata = B12CN_peak_df)) 
colnames(B12CN_quant) <- "est_fmol_on_column"
B12CN_df <- cbind(B12CN_df, B12CN_quant)

# Calculate fmol per mg C and cell
B12CN_df$fmol_cell <- B12CN_df$est_fmol_on_column/B12CN_df$cells_on_column
B12CN_df$fmol_mgC <- B12CN_df$est_fmol_on_column/B12CN_df$mgC_loaded
B12CN_df$peak_cell <- B12CN_df$Final_Peak/B12CN_df$cells_on_column

# B12Me Quant ----------------------------------------------------------------
# Plot B12Me curve with lm 
B12Me_calcurve <- ggplot(B12Me_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B12Me") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B12Me_curve$spike_amount_stadd_corr <- B12Me_curve$spike_amount_corr - as.numeric(coef(B12Me_lm)["(Intercept)"])

# Plot corrected calibration curve
B12Me_calcurve_corrected <- ggplot(B12Me_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: Me-B12 (Corrected)") +
  ylim(0,15000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 5.5, y = 14000, label = lm_eqn(B12Me_curve), parse = TRUE)

# Make corrected lm
B12Me_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B12Me_curve)

#Creating a data frame with B12Me peaks from samples 
B12Me_df <- metab_data_samples_info %>% filter(Molecule.Name == "B12-Me")
B12Me_peak_df <- B12Me_df %>% dplyr::select(Final_Peak) 
colnames(B12Me_peak_df) <- "Final_Peak"

B12Me_df_expraw <- B12Me_df

# B12Me_df$technical_rep <- c("1", "2", "3")
# ggplot(data = B12Me_df, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Final_Peak)) +
#   geom_bar(position = "dodge", stat="identity") +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD, linetype='dotted', col = 'red') +
#   geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
#   xlab("Injection Number") +
#   ylab ("Normalized Peak") + 
#   scale_alpha_manual(values = c(1, .5)) +
#   # scale_x_discrete(labels=c("06" = "06; +B12", "15" = "15; -B12",
#   #                                                "16" = "16; -B12", "24" = "24; +B12", "27" = "27; -B12", "28" = "28; +B12")) +
#   ggtitle("Me-B12 LOD/LOQ") +
#   theme(text = element_text(size = 20))
# 
# Create an empty column for knowing if sample is below LOD
B12Me_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Me_peak_df)){
  if (B12Me_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOD){
    B12Me_df$Below_LOD[i] <- TRUE
    B12Me_df$Final_Peak[i] <- 0
  }
  else{
    B12Me_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B12Me_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B12Me_peak_df)){
  if (B12Me_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B12-Me"))$LOQ){
    B12Me_df$Below_LOQ[i] <- TRUE
  }
  else{
    B12Me_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B12Me_df$normtype <- "BMIS_cell"
B12Me_df$normunits <- "fmol_cell"

# Predict quant values from lm
B12Me_quant <- data.frame(predict(B12Me_lm_corr, newdata = B12Me_peak_df)) 
colnames(B12Me_quant) <- "est_fmol_on_column"
B12Me_df <- cbind(B12Me_df, B12Me_quant)

# Calculate fmol per mg C and cell
B12Me_df$fmol_cell <- B12Me_df$est_fmol_on_column/B12Me_df$cells_on_column
B12Me_df$fmol_mgC <- B12Me_df$est_fmol_on_column/B12Me_df$mgC_loaded
B12Me_df$peak_cell <- B12Me_df$Final_Peak/B12Me_df$cells_on_column


# B7 Quant ----------------------------------------------------------------
# Plot B7 curve with lm 
B7_calcurve <- ggplot(B7_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B7") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
B7_curve$spike_amount_stadd_corr <- B7_curve$spike_amount_corr - as.numeric(coef(B7_lm)["(Intercept)"])

# Plot corrected calibration curve
B7_calcurve_corrected <- ggplot(B7_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: B7 (Corrected)") +
  #ylim(0,1600000) +
#  xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B7"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "B7"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 200, y = 4.5E5, label = lm_eqn(B7_curve), parse = TRUE)

# Make corrected lm
B7_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = B7_curve)

#Creating a data frame with B7 peaks from samples 
B7_df <- metab_data_samples_info %>% filter(Molecule.Name == "B7")
B7_peak_df <- B7_df %>% dplyr::select(Final_Peak) 
colnames(B7_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
B7_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(B7_peak_df)){
  if (B7_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B7"))$LOD){
    B7_df$Below_LOD[i] <- TRUE
    B7_df$Final_Peak[i] <- 0
  }
  else{
    B7_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
B7_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(B7_peak_df)){
  if (B7_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "B7"))$LOQ){
    B7_df$Below_LOQ[i] <- TRUE
  }
  else{
    B7_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
B7_df$normtype <- "BMIS_cell"
B7_df$normunits <- "fmol_cell"

# Predict quant values from lm
B7_quant <- data.frame(predict(B7_lm_corr, newdata = B7_peak_df)) 
colnames(B7_quant) <- "est_fmol_on_column"
B7_df <- cbind(B7_df, B7_quant)

# Calculate fmol per mg C and cell
B7_df$fmol_cell <- B7_df$est_fmol_on_column/B7_df$cells_on_column
B7_df$fmol_mgC <- B7_df$est_fmol_on_column/B7_df$mgC_loaded
B7_df$peak_cell <- B7_df$Final_Peak/B7_df$cells_on_column

# cHET Quant ----------------------------------------------------------------
# Plot cHET curve with lm 
cHET_calcurve <- ggplot(cHET_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: cHET") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
cHET_curve$spike_amount_stadd_corr <- cHET_curve$spike_amount_corr - as.numeric(coef(cHET_lm)["(Intercept)"])

# Plot corrected calibration curve
cHET_calcurve_corrected <- ggplot(cHET_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: cHET (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 600) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 220, y = 4.75e6, label = lm_eqn(cHET_curve), parse = TRUE)

# Make corrected lm
cHET_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = cHET_curve)

#Creating a data frame with cHET peaks from samples 
cHET_df <- metab_data_samples_info %>% filter(Molecule.Name == "cHET")
cHET_peak_df <- cHET_df %>% dplyr::select(Final_Peak) 
colnames(cHET_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
cHET_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(cHET_peak_df)){
  if (cHET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOD){
    cHET_df$Below_LOD[i] <- TRUE
    cHET_df$Final_Peak[i] <- 0
  }
  else{
    cHET_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
cHET_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(cHET_peak_df)){
  if (cHET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "cHET"))$LOQ){
    cHET_df$Below_LOQ[i] <- TRUE
  }
  else{
    cHET_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
cHET_df$normtype <- "BMIS_cell"
cHET_df$normunits <- "fmol_cell"

# Predict quant values from lm
cHET_quant <- data.frame(predict(cHET_lm_corr, newdata = cHET_peak_df)) 
colnames(cHET_quant) <- "est_fmol_on_column"
cHET_df <- cbind(cHET_df, cHET_quant)

# Calculate fmol per mg C and cell
cHET_df$fmol_cell <- cHET_df$est_fmol_on_column/cHET_df$cells_on_column
cHET_df$fmol_mgC <- cHET_df$est_fmol_on_column/cHET_df$mgC_loaded
cHET_df$peak_cell <- cHET_df$Final_Peak/cHET_df$cells_on_column


# FAMP Quant ----------------------------------------------------------------
# Plot FAMP curve with lm 
FAMP_calcurve <- ggplot(FAMP_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: FAMP") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
FAMP_curve$spike_amount_stadd_corr <- FAMP_curve$spike_amount_corr - as.numeric(coef(FAMP_lm)["(Intercept)"])

# Plot corrected calibration curve
FAMP_calcurve_corrected <- ggplot(FAMP_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: FAMP (Corrected)") +
  #ylim(0,1600000) +
 # xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 200, y = 1600000, label = lm_eqn(FAMP_curve), parse = TRUE)

# Make corrected lm
FAMP_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = FAMP_curve)

#Creating a data frame with FAMP peaks from samples 
FAMP_df <- metab_data_samples_info %>% filter(Molecule.Name == "FAMP")
FAMP_peak_df <- FAMP_df %>% dplyr::select(Final_Peak) 
colnames(FAMP_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
FAMP_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(FAMP_peak_df)){
  if (FAMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOD){
    FAMP_df$Below_LOD[i] <- TRUE
    FAMP_df$Final_Peak[i] <- 0
  }
  else{
    FAMP_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
FAMP_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(FAMP_peak_df)){
  if (FAMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "FAMP"))$LOQ){
    FAMP_df$Below_LOQ[i] <- TRUE
  }
  else{
    FAMP_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
FAMP_df$normtype <- "none"
FAMP_df$normunits <- "none"

# Predict quant values from lm
FAMP_quant <- data.frame(predict(FAMP_lm_corr, newdata = FAMP_peak_df)) 
colnames(FAMP_quant) <- "est_fmol_on_column"
FAMP_df <- cbind(FAMP_df, FAMP_quant)

# Calculate fmol per mg C and cell
FAMP_df$fmol_cell <- FAMP_df$est_fmol_on_column/FAMP_df$cells_on_column
FAMP_df$fmol_mgC <- FAMP_df$est_fmol_on_column/FAMP_df$mgC_loaded
FAMP_df$peak_cell <- FAMP_df$Final_Peak/FAMP_df$cells_on_column


# HET Quant ----------------------------------------------------------------
# Plot HET curve with lm 
HET_calcurve <- ggplot(HET_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HET") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
HET_curve$spike_amount_stadd_corr <- HET_curve$spike_amount_corr - as.numeric(coef(HET_lm)["(Intercept)"])

# Plot corrected calibration curve
HET_calcurve_corrected <- ggplot(HET_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HET (Corrected)") +
  #ylim(0,1600000) +
  #xlim(0, 15) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HET"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HET"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 200, y = 1.2e7, label = lm_eqn(HET_curve), parse = TRUE)

# Make corrected lm
HET_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = HET_curve)

#Creating a data frame with HET peaks from samples 
HET_df <- metab_data_samples_info %>% filter(Molecule.Name == "HET")
HET_peak_df <- HET_df %>% dplyr::select(Final_Peak) 
colnames(HET_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
HET_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(HET_peak_df)){
  if (HET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HET"))$LOD){
    HET_df$Below_LOD[i] <- TRUE
    HET_df$Final_Peak[i] <- 0
  }
  else{
    HET_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
HET_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(HET_peak_df)){
  if (HET_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HET"))$LOQ){
    HET_df$Below_LOQ[i] <- TRUE
  }
  else{
    HET_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
HET_df$normtype <- "none"
HET_df$normunits <- "none"

# Predict quant values from lm
HET_quant <- data.frame(predict(HET_lm_corr, newdata = HET_peak_df)) 
colnames(HET_quant) <- "est_fmol_on_column"
HET_df <- cbind(HET_df, HET_quant)

# Calculate fmol per mg C and cell
HET_df$fmol_cell <- HET_df$est_fmol_on_column/HET_df$cells_on_column
HET_df$fmol_mgC <- HET_df$est_fmol_on_column/HET_df$mgC_loaded
HET_df$peak_cell <- HET_df$Final_Peak/HET_df$cells_on_column

# HMP Quant ----------------------------------------------------------------
# Plot HMP curve with lm 
HMP_calcurve <- ggplot(HMP_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HMP") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
HMP_curve$spike_amount_stadd_corr <- HMP_curve$spike_amount_corr - as.numeric(coef(HMP_lm)["(Intercept)"])

# Plot corrected calibration curve
HMP_calcurve_corrected <- ggplot(HMP_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
#  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: HMP (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 750) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 300, y = 1400000, label = lm_eqn(HMP_curve), parse = TRUE)

# Make corrected lm
HMP_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = HMP_curve)

#Creating a data frame with HMP peaks from samples 
HMP_df <- metab_data_samples_info %>% filter(Molecule.Name == "HMP")
HMP_peak_df <- HMP_df %>% dplyr::select(Final_Peak) 
colnames(HMP_peak_df) <- "Final_Peak"

hmp_plottdf <- HMP_df
hmp_plottdf$technical_rep <- c("1", "2", "3")
hmp_repplot <- ggplot(data = hmp_plottdf, aes(fill = technical_rep, alpha = B12.Treatment, x = Replicate.Name, y = Total.Area)) +
  geom_bar(position = "dodge", stat="identity") +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  xlab("Biological Replicate") +
  ylab ("Normalized Peak") +
  scale_alpha_manual(values = c(1, .5)) +
  theme(text = element_text(size = 20)) +
  facet_grid(.~B12.Treatment, scales = "free") + 
  theme(legend.position = "none") +
  ggtitle("HMP") +
  scale_fill_manual(values=met.brewer("Cross", 5))

# Create an empty column for knowing if sample is below LOD
HMP_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(HMP_peak_df)){
  if (HMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOD){
    HMP_df$Below_LOD[i] <- TRUE
    HMP_df$Final_Peak[i] <- 0
  }
  else{
    HMP_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
HMP_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(HMP_peak_df)){
  if (HMP_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "HMP"))$LOQ){
    HMP_df$Below_LOQ[i] <- TRUE
  }
  else{
    HMP_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
HMP_df$normtype <- "none"
HMP_df$normunits <- "none"

# Predict quant values from lm
HMP_quant <- data.frame(predict(HMP_lm_corr, newdata = HMP_peak_df)) 
colnames(HMP_quant) <- "est_fmol_on_column"
HMP_df <- cbind(HMP_df, HMP_quant)

# Calculate fmol per mg C and cell
HMP_df$fmol_cell <- HMP_df$est_fmol_on_column/HMP_df$cells_on_column
HMP_df$fmol_mgC <- HMP_df$est_fmol_on_column/HMP_df$mgC_loaded
HMP_df$peak_cell <- HMP_df$Final_Peak/HMP_df$cells_on_column

# SAH Quant ----------------------------------------------------------------
# Plot SAH curve with lm 
SAH_calcurve <- ggplot(SAH_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAH") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
SAH_curve$spike_amount_stadd_corr <- SAH_curve$spike_amount_corr - as.numeric(coef(SAH_lm)["(Intercept)"])

# Plot corrected calibration curve
SAH_calcurve_corrected <- ggplot(SAH_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  #theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAH (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 650) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOQ, linetype='dotted', col = 'green', size = .75) +
  geom_text(x = 210, y = 50000, label = lm_eqn(SAH_curve), parse = TRUE)

# Make corrected lm
SAH_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = SAH_curve)

#Creating a data frame with SAH peaks from samples 
SAH_df <- metab_data_samples_info %>% filter(Molecule.Name == "SAH")
SAH_peak_df <- SAH_df %>% dplyr::select(Final_Peak) 
colnames(SAH_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
SAH_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAH_peak_df)){
  if (SAH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOD){
    SAH_df$Below_LOD[i] <- TRUE
    SAH_df$Final_Peak[i] <- 0
  }
  else{
    SAH_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
SAH_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAH_peak_df)){
  if (SAH_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAH"))$LOQ){
    SAH_df$Below_LOQ[i] <- TRUE
  }
  else{
    SAH_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
SAH_df$normtype <- "BMIS_cell"
SAH_df$normunits <- "fmol_cell"

# Predict quant values from lm
SAH_quant <- data.frame(predict(SAH_lm_corr, newdata = SAH_peak_df)) 
colnames(SAH_quant) <- "est_fmol_on_column"
SAH_df <- cbind(SAH_df, SAH_quant)

# Calculate fmol per mg C and cell
SAH_df$fmol_cell <- SAH_df$est_fmol_on_column/SAH_df$cells_on_column
SAH_df$fmol_mgC <- SAH_df$est_fmol_on_column/SAH_df$mgC_loaded
SAH_df$peak_cell <- SAH_df$Final_Peak/SAH_df$cells_on_column

# SAM Quant ----------------------------------------------------------------
# Plot SAM curve with lm 
SAM_calcurve <- ggplot(SAM_curve, aes(spike_amount_corr, Final_Peak)) +
  geom_point(size = 8) +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
  theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAM") +
  #  ylim(0,1600000) +
  # xlim(-255, 550) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) 

# Make new df corrected for standard addition
SAM_curve$spike_amount_stadd_corr <- SAM_curve$spike_amount_corr - as.numeric(coef(SAM_lm)["(Intercept)"])

# Plot corrected calibration curve
SAM_calcurve_corrected <- ggplot(SAM_curve, aes(spike_amount_stadd_corr, Final_Peak)) +
  geom_point() +
  xlab("Spike Amount (fmol)") +
  ylab("Peak Area") + 
 # theme(text = element_text(size = 20)) +
  ggtitle("Calibration Curve: SAM (Corrected)") +
  #ylim(0,1600000) +
  xlim(0, 700) +
  geom_smooth(method='lm', formula= y~x, fullrange = TRUE) +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOD, linetype='dotted', col = 'red') +
  geom_hline(yintercept = (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOQ, linetype='dotted', col = 'green', size = .75) + 
  geom_text(x = 300, y = 90000, label = lm_eqn(SAM_curve), parse = TRUE)

# Make corrected lm
SAM_lm_corr <- lm(spike_amount_stadd_corr ~ Final_Peak , data = SAM_curve)

#Creating a data frame with SAM peaks from samples 
SAM_df <- metab_data_samples_info %>% filter(Molecule.Name == "SAM")
SAM_peak_df <- SAM_df %>% dplyr::select(Final_Peak) 
colnames(SAM_peak_df) <- "Final_Peak"


# Create an empty column for knowing if sample is below LOD
SAM_peak_df$Below_LOD <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAM_peak_df)){
  if (SAM_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOD){
    SAM_df$Below_LOD[i] <- TRUE
    SAM_df$Final_Peak[i] <- 0
  }
  else{
    SAM_df$Below_LOD[i] <- FALSE
  }
}

# Create an empty column for knowing if sample is below LOQ
SAM_peak_df$Below_LOQ <- NA

# notify if sample is below LOD
for (i in 1:nrow(SAM_peak_df)){
  if (SAM_peak_df$Final_Peak[i] < (LODQ_df %>% filter(Molecule.Name == "SAM"))$LOQ){
    SAM_df$Below_LOQ[i] <- TRUE
  }
  else{
    SAM_df$Below_LOQ[i] <- FALSE
  }
}


# Get recommended norm type
# if >1/2 samples are below LOD, no quant
# if <1/2 samples are below LOD, relative quant 
# If all samples above LOQ, absolute quant
# notify if sample is below LOD
SAM_df$normtype <- "BMIS_cell"
SAM_df$normunits <- "fmol_cell"

# Predict quant values from lm
SAM_quant <- data.frame(predict(SAM_lm_corr, newdata = SAM_peak_df)) 
colnames(SAM_quant) <- "est_fmol_on_column"
SAM_df <- cbind(SAM_df, SAM_quant)

# Calculate fmol per mg C and cell
SAM_df$fmol_cell <- SAM_df$est_fmol_on_column/SAM_df$cells_on_column
SAM_df$fmol_mgC <- SAM_df$est_fmol_on_column/SAM_df$mgC_loaded
SAM_df$peak_cell <- SAM_df$Final_Peak/SAM_df$cells_on_column


metab_quant_export_df <- rbind(B1_df, B12Ado_df, B12CN_df, B12OH_df, B12Me_df, B7_df, cHET_df, FAMP_df, HET_df, HMP_df, SAH_df, SAM_df)
write.csv(metab_quant_export_df, file = "metab_quant_export_df_19022022.csv")

b12_quant_expraw <- rbind(B12Ado_df_expraw, B12CN_df_expraw,B12OH_df_expraw, B12Me_df_expraw)
write.csv(b12_quant_expraw, file = "b12_quant_expraw_04032022.csv")

# Export plot with all cal curves
ggarrange(B1_calcurve_corrected, B12Ado_calcurve_corrected, B12OH_calcurve_corrected, B12CN_calcurve_corrected, B12Me_calcurve_corrected, B7_calcurve_corrected) 

ggarrange(cHET_calcurve_corrected, FAMP_calcurve_corrected, HET_calcurve_corrected, HMP_calcurve_corrected, SAH_calcurve_corrected, SAM_calcurve_corrected)


